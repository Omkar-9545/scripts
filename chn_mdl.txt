// ============================================================
// CHANNEL MODEL MICROARCHITECTURE - SYSTEMVERILOG RTL MODULES
// ============================================================

// 1. Delay Chain (31-stage Shift Register)
module delay_chain #(parameter WIDTH = 16) (
  input logic clk,
  input logic rst,
  input logic flush,
  input logic [WIDTH-1:0] data_in,
  output logic [WIDTH-1:0] taps [0:31]
);
  always_ff @(posedge clk or posedge rst) begin
    if (rst || flush) begin
      for (int i = 0; i < 32; i++) taps[i] <= '0;
    end else begin
      taps[0] <= data_in;
      for (int i = 1; i < 32; i++) taps[i] <= taps[i-1];
    end
  end
endmodule

// 2. 32-Tap FIR Filter with Q1.15 coefficients and output in Q6.30
module fir32_q15 (
  input logic clk,
  input logic rst,
  input logic signed [15:0] x[0:31],
  input logic signed [15:0] coeff[0:31],
  output logic signed [35:0] y // Q6.30
);
  logic signed [31:0] mult [0:31];
  logic signed [35:0] acc;

  always_comb begin
    for (int i = 0; i < 32; i++)
      mult[i] = x[i] * coeff[i]; // Q1.15 * Q1.15 = Q2.30
  end

  always_ff @(posedge clk or posedge rst) begin
    if (rst) y <= 0;
    else begin
      acc = 0;
      for (int i = 0; i < 32; i++) acc += mult[i];
      y <= acc;
    end
  end
endmodule

// 3. FIFO (using BRAM externally)
module fifo_q630 #(parameter DEPTH = 1024) (
  input logic clk,
  input logic rst,
  input logic wr_en,
  input logic rd_en,
  input logic signed [35:0] din,
  output logic signed [35:0] dout,
  output logic full,
  output logic empty
);
  logic signed [35:0] mem [0:DEPTH-1];
  logic [$clog2(DEPTH):0] wr_ptr, rd_ptr, count;

  assign full = (count == DEPTH);
  assign empty = (count == 0);
  assign dout = mem[rd_ptr];

  always_ff @(posedge clk or posedge rst) begin
    if (rst) begin
      wr_ptr <= 0;
      rd_ptr <= 0;
      count <= 0;
    end else begin
      if (wr_en && !full) begin
        mem[wr_ptr] <= din;
        wr_ptr <= wr_ptr + 1;
        count <= count + 1;
      end
      if (rd_en && !empty) begin
        rd_ptr <= rd_ptr + 1;
        count <= count - 1;
      end
    end
  end
endmodule

// 4. Adder Tree for 3 inputs (Q6.30) → Q8.30
module adder_tree3 (
  input logic signed [35:0] in0,
  input logic signed [35:0] in1,
  input logic signed [35:0] in2,
  output logic signed [39:0] out // Q8.30
);
  always_comb begin
    out = $signed(in0) + $signed(in1) + $signed(in2);
  end
endmodule

// 5. Final Precision Converter: Q8.30 → Q1.15 with round, saturate, truncate
module precision_converter (
  input logic clk,
  input logic rst,
  input logic signed [39:0] in,    // Q8.30
  output logic signed [15:0] out,  // Q1.15
  output logic overflow_sticky,
  input logic reset_sticky
);
  logic signed [42:0] shifted; // Q8.33 after shift
  logic sticky_reg;

  always_ff @(posedge clk or posedge rst) begin
    if (rst) begin
      out <= 0;
      overflow_sticky <= 0;
    end else begin
      shifted = (in <<< 3) + 43'd4; // round by adding 2^(3-1) = 4

      if (shifted > 43'sh7FFF0000) begin
        out <= 16'sh7FFF;
        sticky_reg <= 1;
      end else if (shifted < -43'sh80000000) begin
        out <= -16'sh8000;
        sticky_reg <= 1;
      end else begin
        out <= shifted[42:27]; // Take [42:27] for Q1.15
      end

      if (reset_sticky)
        sticky_reg <= 0;
      overflow_sticky <= sticky_reg;
    end
  end
endmodule

// 6. Stream Controller (BRAM input, handles flush)
module stream_controller (
  input logic clk,
  input logic rst,
  input logic [15:0] bram_data,
  input logic start,
  input logic flush,
  output logic [15:0] stream_out,
  output logic valid
);
  logic [15:0] stream_reg;

  always_ff @(posedge clk or posedge rst) begin
    if (rst) begin
      stream_reg <= 0;
      valid <= 0;
    end else if (start) begin
      if (flush) begin
        stream_reg <= 0;
      end else begin
        stream_reg <= bram_data;
      end
      valid <= 1;
    end else begin
      valid <= 0;
    end
  end

  assign stream_out = stream_reg;
endmodule

// 7. Top-Level Module for Channel Model
module channel_model_top (
  input logic clk,
  input logic rst,
  input logic start,
  input logic flush,
  input logic reset_sticky,
  input logic [15:0] bram_data,
  input logic signed [15:0] coeff [0:31],
  output logic [15:0] final_output,
  output logic sticky_flag
);
  // Intermediate wires
  logic [15:0] stream;
  logic [15:0] taps0 [0:31], taps1 [0:31], taps2 [0:31];
  logic signed [35:0] y0, y1, y2;
  logic signed [35:0] f0_out, f1_out, f2_out;
  logic signed [39:0] sum;

  // Instantiate stream controller
  stream_controller stream_ctrl (
    .clk(clk), .rst(rst), .bram_data(bram_data), .start(start), .flush(flush),
    .stream_out(stream), .valid()
  );

  // First delay chain and filter
  delay_chain dc0 (.clk(clk), .rst(rst), .flush(flush), .data_in(stream), .taps(taps0));
  fir32_q15 f0 (.clk(clk), .rst(rst), .x(taps0), .coeff(coeff), .y(y0));

  // FIFO0
  fifo_q630 fifo0 (.clk(clk), .rst(rst), .wr_en(1), .rd_en(1), .din(y0), .dout(f0_out), .full(), .empty());

  // Second delay chain and filter
  delay_chain dc1 (.clk(clk), .rst(rst), .flush(flush), .data_in(stream), .taps(taps1));
  fir32_q15 f1 (.clk(clk), .rst(rst), .x(taps1), .coeff(coeff), .y(y1));

  fifo_q630 fifo1 (.clk(clk), .rst(rst), .wr_en(1), .rd_en(1), .din(y1), .dout(f1_out), .full(), .empty());

  // Third delay chain and filter
  delay_chain dc2 (.clk(clk), .rst(rst), .flush(flush), .data_in(stream), .taps(taps2));
  fir32_q15 f2 (.clk(clk), .rst(rst), .x(taps2), .coeff(coeff), .y(y2));

  fifo_q630 fifo2 (.clk(clk), .rst(rst), .wr_en(1), .rd_en(1), .din(y2), .dout(f2_out), .full(), .empty());

  // Adder tree and converter
  adder_tree3 adder (.in0(f0_out), .in1(f1_out), .in2(f2_out), .out(sum));

  precision_converter conv (
    .clk(clk), .rst(rst), .in(sum), .out(final_output),
    .overflow_sticky(sticky_flag), .reset_sticky(reset_sticky)
  );
endmodule
